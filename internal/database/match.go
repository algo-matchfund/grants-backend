package database

import (
	"database/sql"
	"errors"
	"log"
	"math"
)

type MatchAmount struct {
	ProjectId    string
	Fund         uint64
	Contributors uint
	Match        float64
	Factor       float64
	Percent      float64
}

type IntermediateMatch struct {
	ProjectId    string
	Match        float64
	Fund         uint64
	Contributors uint
}

func CalculateMatches(funds []*Fund, matchingPool uint64) []MatchAmount {
	matches := []IntermediateMatch{}
	for _, f := range funds {
		// for first donation to project, deliberately equate match to donation amount
		if len(f.Amount) == 1 {
			match := IntermediateMatch{
				ProjectId:    f.ProjectId,
				Match:        float64(f.Amount[0]),
				Fund:         f.Amount[0],
				Contributors: 1,
			}

			matches = append(matches, match)

			continue
		}

		amount := 0.0
		totalFund := uint64(0)
		for _, a := range f.Amount {
			totalFund += a
			amount += math.Sqrt(float64(a))
		}
		amount *= amount

		match := IntermediateMatch{
			ProjectId:    f.ProjectId,
			Match:        amount - float64(totalFund),
			Fund:         totalFund,
			Contributors: uint(len(f.Amount)),
		}

		matches = append(matches, match)
	}

	totalMatch := 0.0
	for _, m := range matches {
		totalMatch += m.Match
	}

	matchAmounts := []MatchAmount{}
	for _, m := range matches {
		var factor float64
		if totalMatch > 0 {
			factor = float64(matchingPool) / totalMatch
		} else {
			factor = 1
		}
		match := m.Match
		if totalMatch > float64(matchingPool) {
			match = m.Match * factor
		}
		percent := m.Match * factor / 100000000
		matchAmount := MatchAmount{
			ProjectId:    m.ProjectId,
			Fund:         m.Fund,
			Contributors: m.Contributors,
			Match:        match,
			Factor:       factor,
			Percent:      percent,
		}
		matchAmounts = append(matchAmounts, matchAmount)
	}

	return matchAmounts
}

func GetNewMatches(funds []*Fund, matchingPool uint64, projectId string, amount uint64) []MatchAmount {
	for _, f := range funds {
		if f.ProjectId == projectId {
			f.Amount = append(f.Amount, amount)
		}
	}
	return CalculateMatches(funds, matchingPool)
}

// Return a value of match generated by fund provided by user
func (db *GrantsDatabase) GetProjectMatchCalculation(projectId string, amount int64) (float64, error) {
	stmt, params, err := db.builder.Select("id").
		From("projects").
		Where("id = ?", projectId).ToSql()

	if err != nil {
		log.Println(err)
		return 0, err
	}

	row := db.QueryRow(stmt, params...)
	if row.Err() != nil {
		return 0, errors.New("cannot find project when calculating new match amount")
	}

	var res sql.NullFloat64
	stmt, params, err = db.builder.Select("match").
		From("matches").
		Where("project_id = ?", projectId).ToSql()

	if err != nil {
		log.Println(err)
		return 0, err
	}

	row = db.QueryRow(stmt, params...)
	err = row.Scan(&res)

	currentMatch := 0.0
	if err == nil {
		currentMatch = res.Float64
	}

	matchingPool, err := db.GetCurrentMatchingRound()
	if err != nil {
		return 0, err
	}

	funds, err := db.getFunds(matchingPool.ID)
	if err != nil {
		return 0, err
	}

	newMatchAmounts := GetNewMatches(funds, uint64(matchingPool.MatchAmount), projectId, uint64(amount))

	newMatch := 0.0
	for _, m := range newMatchAmounts {
		if m.ProjectId == projectId {
			newMatch = m.Match
			break
		}
	}

	if newMatch == 0.0 {
		return 0, errors.New("failed to calculate project match")
	}

	return newMatch - currentMatch, err
}

func (db *GrantsDatabase) UpdateMatches() error {

	matchingPool, err := db.GetCurrentMatchingRound()
	if err != nil {
		return err
	}

	funds, err := db.getFunds(matchingPool.ID)
	if err != nil {
		return err
	}

	matches := CalculateMatches(funds, uint64(matchingPool.MatchAmount))

	for _, match := range matches {
		stmt, params, err := db.builder.
			Insert("matches").
			Columns("project_id, fund, contributors, match, factor, percent").
			Values(match.ProjectId, match.Fund, match.Contributors, match.Match, match.Factor, match.Percent).
			Suffix("ON CONFLICT ON CONSTRAINT matches_project_id_pk DO UPDATE SET contributors = ?, fund = ?, match = ?, factor = ?, percent = ?", match.Contributors, match.Fund, match.Match, match.Factor, match.Percent).
			ToSql()

		if err != nil {
			return err
		}

		_, err = db.Exec(stmt, params...)
		if err != nil {
			return err
		}
	}

	return nil
}
